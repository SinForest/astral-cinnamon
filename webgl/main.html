<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - camera - orthographic</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="three.min.js"></script>
		<script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
		
		<script>

			var container/*, stats;*/;
			var camera, scene, renderer;
			
			var vect = getFromText("inputs.txt");
			var leftUpperLongitude  = 8.697083; //Laengengrad X		x0 
            var leftUpperLatitude   = 49.412132;//Breitengrad Y     y0
            var rightBottomLongitude= 8.700972; //Laengengrad X     x1
            var rightBottomLatitude = 49.410429;//Breitengrad Y     y1
			
			init();
			animate();			
			
	        function getFromText(input)
	        {
                var vectors = new Array();
                $.ajax({
	                url: input,
	                dataType: "text",
	                async: false,
	                success: function(data){
                       var tmp_1 = data.split("\n");
                       for(var i=0; i < tmp_1.length; i++) {
	                       vectors[i] = new Array();                                                      
	                       //LINESTRING( ) entfernen
	                       tmp_1[i] = tmp_1[i].substring(11, tmp_1[i].indexOf(")"));
	                      
	                       var tmp_2 = tmp_1[i].split(",");                                                       
	                       for(var j=0; j < tmp_2.length; j++)
	                       {
								vectors[i][j] = tmp_2[j].split(" ");
								for(var k=0;k<vectors[i][j].length;k++) {
									vectors[i][j][k] = parseFloat(vectors[i][j][k]);
									
								}
	                       }
                       }                                              
	                }
                });    
                return vectors;
	        }

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );
				
				
				camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 500, 2000 );
				camera.position.x = 200;
				camera.position.y = 100;
				camera.position.z = 200;

				scene = new THREE.Scene();


				//Vektoren hinzufÃ¼gen
				
				var geometry = new THREE.Geometry();
				
				
				/*var Xmax = rightBottomLongitude - leftUpperLongitude;                                  
                var Ymax = rightBottomLatitude - leftUpperLatitude;
				for (var stra=0; stra < vect.length; stra++)
                {
                    for (var vec=0; vec < vect[stra].length-1; vec++)
                    {    
                    	var XKordStart = (vect[stra][vec][0] - leftUpperLongitude) / (Xmax/window.innerWidth);
                        var YKordStart = (vect[stra][vec][1] - leftUpperLatitude) / (Ymax/window.innerHeight);
                        var XKordFinish = (vect[stra][vec+1][0] - leftUpperLongitude) / (Xmax/window.innerWidth);
                        var YKordFinish = (vect[stra][vec+1][1] - leftUpperLatitude) / (Ymax/window.innerHeight);
                        
                        geometry.vertices.push( new THREE.Vector3(XKordStart , YKordStart, 0 ) ); //Startwert
        				geometry.vertices.push( new THREE.Vector3(XKordFinish, YKordFinish, 0 ) ); //Endwert
					}
				}	*/			
				//geometry.vertices.push( new THREE.Vector3( 0, 0,50 ) );
				//geometry.vertices.push( new THREE.Vector3( 50, 0, 0 ) );
				
				var Xmax = rightBottomLongitude - leftUpperLongitude;					
				var Ymax = rightBottomLatitude - leftUpperLatitude;
				for (var stra=0; stra < vect.length; stra++)
				{
					vect[stra][0][0] -= leftUpperLongitude;
					vect[stra][0][1] -= leftUpperLatitude;
					vect[stra][0][0] /= (Xmax/window.innerWidth);
					vect[stra][0][1] /= (Ymax/window.innerHeight);
					for (var vec=0; vec < vect[stra].length-1; vec++)
					{
						vect[stra][vec+1][0] -= leftUpperLongitude;
						vect[stra][vec+1][1] -= leftUpperLatitude;
							// Jeder Vektor wird relativ zur oberen, linken Ecke angegeben;
						vect[stra][vec+1][0] /= (Xmax/window.innerWidth);
						vect[stra][vec+1][1] /= (Ymax/window.innerHeight);
						//alert(vect[stra][vec][0]+"\n"+vect[stra][vec][1]+"\n"+vect[stra][vec+1][0]+"\n"+vect[stra][vec+1][1]);
						
						geometry.vertices.push( new THREE.Vector3(vect[stra][vec][0], vect[stra][vec][1], 0 ) ); //Startwert
        				geometry.vertices.push( new THREE.Vector3(vect[stra][vec+1][0], vect[stra][vec+1][1], 0 ) ); //Endwert	
					}
				}
				
				
				var material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 1,linewidth: 2 } ); //Eigenschaften der Vektoren

				var streets = new THREE.Line( geometry, material );
				streets.type = THREE.LinePieces;
				scene.add( streets );


				renderer = new THREE.CanvasRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );



				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.left = window.innerWidth / - 2;
				camera.right = window.innerWidth / 2;
				camera.top = window.innerHeight / 2;
				camera.bottom = window.innerHeight / - 2;

				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				//stats.update();

			}

			function render() {
				
				camera.position.x = 00;
				camera.position.y = 00;
				camera.position.z = 100;				
				camera.lookAt( scene.position );

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
